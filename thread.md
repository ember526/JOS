以前的unix系统中，线程被当作和进程同样的东西，也就是说没有特别的数据结构来完成线程。以至于在打印主次线程的pid时，会发现是不同的。而现在的操作系统里，执行相同的程序可以看到他们共享同样的pid，不过有不同的tid。在我们的系统中我们没有必要完全模仿某一种特定的线程实现，我们需要针对JOS和unix系统的结构区别来决定JOS中的线程实现。为了决定如何实现线程，我们需要进行很多必要的讨论。

综合多方面的考虑，我决定向每一个进程内部加入对多线程的支持。总体设计上，我希望进程是线程与系统资源交互的一个接口。

我的想法是

## 阶段一
首先是线程的创建。pthread_create库函数在内核中的支持是clone()系统调用。在linux系统中clone有更加广泛的使用，但是在这里只用来创建进程。首先使用env_alloc申请一个空闲的任务块，然后处理的是地址空间。主线程的地址空间可以直接赋给子线程（通过页表地址），但是要处理子线程的栈空间。栈空间对应到任务的数据结构中也就是任务上下文中的esp寄存器了，同时父进程通过pthread_create函数的start_routine参数来决定子线程的eip（也就是接下来要执行的指令位置）。对于栈空间，这里需要有一些讨论。

首先，我们在阶段一要有两个假设：1)不考虑线程销毁的情况，也就是说线程栈也不会销毁2)假设子线程不会占用异常栈。实现过程中的任何假设在后续阶段都需要解决。那么从USTACKTOP向下的每两个PGSIZE中，靠上的一个PGSIZE作为一个线程栈，靠下的一个PGSIZE被当作保护区，防止不被察觉的栈溢出情况。在创建线程的时候就需要找到新线程“对应”的栈位置。显然，每一个进程应该有相应的机制来确定这个位置；在不考虑线程销毁的情况下，只需要在父进程中保存有多少个线程即可。但是这个栈不可以是空的，因为从函数调用的角度考虑：1)新的线程需要从栈上获取参数2)在线程结束之后return语句将要在栈上获取返回地址。新的问题来了：线程结束之后应该返回到哪里。

到这里，阶段一已经结束了，因为程序已经可以执行基本的功能：创建进程，并且在线程上执行代码。

## 阶段二

这里我希望线程函数不用调用额外的函数来结束，而是直接使用return语句；而且我还希望，线程销毁的有关函数