以前的unix系统中，线程被当作和进程同样的东西，也就是说没有特别的数据结构来完成线程。以至于在打印主次线程的pid时，会发现是不同的。而现在的操作系统里，执行相同的程序可以看到他们共享同样的pid，不过有不同的tid。在我们的系统中我们没有必要完全模仿某一种特定的线程实现，我们需要针对JOS和unix系统的结构区别来决定JOS中的线程实现。为了决定如何实现线程，我们需要进行很多必要的讨论。

综合多方面的考虑，我决定向每一个进程内部加入对多线程的支持。总体设计上，我希望进程是线程与系统资源交互的一个接口。

我的想法是

## 阶段一
首先是线程的创建。pthread_create库函数在内核中的支持是clone()系统调用。在linux系统中clone有更加广泛的使用，但是在这里只用来创建进程。首先使用env_alloc申请一个空闲的任务块，然后处理的是地址空间。主线程的地址空间可以直接赋给子线程（通过页表地址），但是要处理子线程的栈空间。栈空间对应到任务的数据结构中也就是任务上下文中的esp寄存器了，同时父进程通过pthread_create函数的start_routine参数来决定子线程的eip（也就是接下来要执行的指令位置）。对于栈空间，这里需要有一些讨论。

首先，我们在阶段一要有两个假设：1)不考虑线程销毁的情况，也就是说线程栈也不会销毁2)假设子线程不会占用异常栈。实现过程中的任何假设在后续阶段都需要解决。那么从USTACKTOP向下的每两个PGSIZE中，靠上的一个PGSIZE作为一个线程栈，靠下的一个PGSIZE被当作保护区，防止不被察觉的栈溢出情况。在创建线程的时候就需要找到新线程“对应”的栈位置。显然，每一个进程应该有相应的机制来确定这个位置；在不考虑线程销毁的情况下，只需要在父进程中保存有多少个线程即可。但是这个栈不可以是空的，因为从函数调用的角度考虑：1)新的线程需要从栈上获取参数2)在线程结束之后return语句将要在栈上获取返回地址。新的问题来了：线程结束之后应该返回到哪里。

到这里，阶段一已经结束了，因为程序已经可以执行基本的功能：创建进程，并且在线程上执行代码。

## 阶段二
为线程设定返回地址本应该是一个简单的事情：线程栈的最上方的四字节是线程函数的参数，接下来的四个字节是返回地址位置。不过问题就在于，这个地址的值由谁来设定。如果直接clone里面在返回地址处填上pthread_exit，编译器是找不到定义的；如果强行包含头文件，那么在执行时会出现页错误，因为此时是内核地址空间中的代码，用户进程不可以执行。所以我设定了专门的系统调用，来从用户空间中传入这个返回函数地址应有的值，sys_set_thread_rtn_routine。

在这个接口调通之后，按理来说应该是进一步实现终止进程的例程了，不过在那之前还需要解决第一阶段的假设之一：线程不会被销毁。首先需要调整线程的结构，每一个进程有一个进程数的上限，在进程控制块中保存线程指针的数组，每一个任务都会被分配一个线程号（主线程是0号），所有线程栈在进程分配的时候就进行映射(load_icode)。在对数据结构进行改进之后，还需要调整clone中的实现。然后是完善线程的终止例程。线程终止分为两个部分，一是释放主线程中的线程相关资源，二是释放任务块。

之后就可以实现pthread_join的功能了。关于join的实现，一定是用表来记录的，而不能只用一个值来表示有多少个join。

在pthread_join实现之后，第二阶段就完成了。

## 阶段三
